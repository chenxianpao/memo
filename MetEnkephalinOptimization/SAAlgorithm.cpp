// SAAlgorithm.cpp: implementation of the CSAAlgorithm class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SAAlgorithm.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSAAlgorithm::CSAAlgorithm(const GAGenome& genome) : GAGeneticAlgorithm(genome) {
	energyEval =0;
	energyEvalSec = 0;
	energyMinimizedValue = 0.0;

	annealingScheduleX = 0.0;
	dInitialAve = 0.0;
	dCut = 0.0;

	energyMinimizedCutOff = 0;
	nicheCutoff = 0;


	firstBank = bank = 0;
	nBank = 0;
}


CSAAlgorithm::~CSAAlgorithm() {
	delete bank;     // don't delete the firstBank;
}


void CSAAlgorithm::initialize(unsigned int seed) {
	energyEval =0;
	energyEvalSec = 0;
	energyMinimizedValue = 0.0;

	GARandomSeed(); //If you call it with no argument,this uses the current time multiplied by the process ID as the seed for a psuedo-random number generator.
	pop->initialize( );
	multipleEnergyMinimize(*pop);
	stats.reset(*pop);

	nBank = pop->size();
	dInitialAve = distanceAverage(*pop);
	dCut = dInitialAve/2.0;

	energyMinimizedCutOff = 20000;
	nicheCutoff = 90;
	annealingScheduleX = pow((nicheCutoff/dCut), 1.0/energyMinimizedCutOff);
	firstBank = pop;
	bank = firstBank->clone();
}

void CSAAlgorithm::step( ) {
	for(int round = 0; round < 9; round++) {
		resetBank(bank);
		
		GAGenome* seed = selectSeedConformation(bank);
		while(seed) {
			GAPopulation* trialP = getTrialConformations(seed, firstBank, bank);
			multipleEnergyMinimize(*trialP);
			upDateBank(trialP, bank);

	
			bank->sort(gaTrue);
			cout << round << "\t" << getCurrentDcut() << "\t" << energyEvalSec << "\t" << energyEval << "\t" << energyMinimizedValue<< "\t";
			cout << distanceAverage(*bank) << "\t";
			screenPrint(&bank->individual(0));
			cout.flush();
	
			seed = selectSeedConformation(seed,bank);
		}
	}
}


GAGenome* CSAAlgorithm::selectSeedConformation(GAPopulation* bank){
	GAGenome* returnGenome = 0;
	bank->sort(gaTrue);
	for(int i=0; i<bank->size(); i++) {
		SeedStatus status = getGenomeSeedStatus(&bank->individual(i));
		if(status==DEUnknown) {
			setGenomeSeedStatus(&bank->individual(i), DETrue);
			returnGenome = &bank->individual(i);
			break;
		}
	}
	return returnGenome;
}

GAGenome* CSAAlgorithm::selectSeedConformation(GAGenome* previousSeed, GAPopulation *bank){
	GAGenome* returnGenome = 0;
	double dave = 0.0;
	int index = 0;

	bank->sort(gaTrue);

	for(int i=0; i<bank->size(); i++) {
		SeedStatus status = getGenomeSeedStatus(&bank->individual(i));
		if(status==DEUnknown) {
			GAGenome* g = &bank->individual(i);
			dave += computerGenomeDistance(previousSeed, g);
			index ++;
		}
	}

	if(index == 0) {
		return 0;
	}else {
		dave = dave/index;
	}
	
	for(i=0; i<bank->size(); i++) {
		SeedStatus status = getGenomeSeedStatus(&bank->individual(i));
		if(status==DEUnknown) {
			double dist = computerGenomeDistance(previousSeed, &bank->individual(i));
			if(dist >= dave) {
				setGenomeSeedStatus(&bank->individual(i), DETrue);
				returnGenome = &bank->individual(i);
				break;
			}
		}
	}

	return returnGenome;
}



GAPopulation* CSAAlgorithm::getTrialConformations(GAGenome*	seedConformation, 
												  GAPopulation*	firstBank, 
												  GAPopulation*	bank)
{
	int i=0;
	int bankSize = firstBank->size();
	int genomeLength = dynamic_cast<GARealGenome*>(seedConformation)->length();

	GAPopulation *trialPopulation = new GAPopulation(*seedConformation, 10);
	for(i=0; i<trialPopulation->size(); i++) {
		GARealGenome* gi = dynamic_cast<GARealGenome*>(&(trialPopulation->individual(i)));
		MyEvalData* pMyEvalData = dynamic_cast<MyEvalData*>(gi->evalData());
		pMyEvalData->setSeedStatus(DEUnknown);
	}
	
	// three conformations are generated by changing a few (one to four for Met-enkephalin) randomly selected dihedral angles of the seed conformation.
	// if the randomly selected dihedral angle of the seed conformation is ui, 
	// we replace it with one of the corresponding ui' in the first bank, which is selected randomly out of the nbank conformations.
	for(i=0; i<3; i++) {
		GARealGenome* trial = dynamic_cast<GARealGenome*>(&(trialPopulation->individual(i)));

		while(computerGenomeDistance(seedConformation, trial) < 30) {
			int numberOfAngleChanged = GARandomInt(1,4);	// changing one to four angles randomly selected dihedral angle of the seed conformation.
			int* indexAngleChangedArray = new int[numberOfAngleChanged]; for(int j=0; j<numberOfAngleChanged;j++) indexAngleChangedArray[j] = -1;
			indexAngleChangedArray[0] = GARandomInt(0,genomeLength-1);
			for(j=1; j<numberOfAngleChanged; j++) {
				do{
					indexAngleChangedArray[j] = GARandomInt(0,genomeLength-1);
				}while(!distinctBeforePositionL(indexAngleChangedArray,j));
			}
			
			for(j=0; j<numberOfAngleChanged; j++) {
				int indexOfSelectedIndividual = GARandomInt(0, bankSize-1);
				GARealGenome* selectedIndividual = dynamic_cast<GARealGenome*>(&(firstBank->individual(indexOfSelectedIndividual)));
				trial->gene(indexAngleChangedArray[j], selectedIndividual->gene(indexAngleChangedArray[j]));
			}

			delete [] indexAngleChangedArray;
		}
	}
	

	// three conformations are generated as above but the dihedral angles are selected only from phi, psi, omega, chi1, 
	// that is, the dihedral angles around the alpha-carbon atom
	for(i=3; i<6; i++) {
		GARealGenome* trial = dynamic_cast<GARealGenome*>(&(trialPopulation->individual(i)));
		while(computerGenomeDistance(seedConformation, trial) < 30) {
			int numberOfAngleChanged = GARandomInt(1,4);	// changing one to four angles randomly selected dihedral angle of the seed conformation.
			int numberOfDihedralAngleAroundAlphaCarbon = 18;// ****** included omega dihedral angle.
			int *indexOfDihedralAngleAroundAlphaCarbon = new int[numberOfDihedralAngleAroundAlphaCarbon];
			indexOfDihedralAngleAroundAlphaCarbon[ 0] = 0;		// Try-Phi		
			indexOfDihedralAngleAroundAlphaCarbon[ 1] = 1;		// Try-Psi
			indexOfDihedralAngleAroundAlphaCarbon[ 2] = 2;		// Try-Omega
			indexOfDihedralAngleAroundAlphaCarbon[ 3] = 3;		// Try-Chi1
		
			indexOfDihedralAngleAroundAlphaCarbon[ 4] = 6;		// Gly1-Phi		
			indexOfDihedralAngleAroundAlphaCarbon[ 5] = 7;		// Gly1-Psi
			indexOfDihedralAngleAroundAlphaCarbon[ 6] = 8;		// Gly1-Omega

			indexOfDihedralAngleAroundAlphaCarbon[ 7] = 9;		// Gly2-Phi		
			indexOfDihedralAngleAroundAlphaCarbon[ 8] = 10;		// Gly2-Psi
			indexOfDihedralAngleAroundAlphaCarbon[ 9] = 11;		// Gly2-Omega

			indexOfDihedralAngleAroundAlphaCarbon[10] = 12;		// Phe-Phi		
			indexOfDihedralAngleAroundAlphaCarbon[11] = 13;		// Phe-Psi
			indexOfDihedralAngleAroundAlphaCarbon[12] = 14;		// Phe-Omega
			indexOfDihedralAngleAroundAlphaCarbon[13] = 15;		// Phe-Chi1		

			indexOfDihedralAngleAroundAlphaCarbon[14] = 17;		// Met-Phi		
			indexOfDihedralAngleAroundAlphaCarbon[15] = 18;		// Met-Psi
			indexOfDihedralAngleAroundAlphaCarbon[16] = 19;		// Met-Omega
			indexOfDihedralAngleAroundAlphaCarbon[17] = 20;		// Met-Chi1	
			

			int* indexAngleChangedArray = new int[numberOfAngleChanged]; for(int j=0; j<numberOfAngleChanged;j++) indexAngleChangedArray[j] = -1;
			indexAngleChangedArray[0] = GARandomInt(0, numberOfDihedralAngleAroundAlphaCarbon-1);
			for(j=1; j<numberOfAngleChanged; j++) {
				do{
					indexAngleChangedArray[j] = GARandomInt(0, numberOfDihedralAngleAroundAlphaCarbon-1);
				}while(!distinctBeforePositionL(indexAngleChangedArray,j));
			}

			
			for(j=0; j<numberOfAngleChanged; j++) {
				int indexOfSelectedIndividual = GARandomInt(0, bankSize-1);
				GARealGenome* selectedIndividual = dynamic_cast<GARealGenome*>(&(firstBank->individual(indexOfSelectedIndividual)));

				int index = indexOfDihedralAngleAroundAlphaCarbon[indexAngleChangedArray[j]];
				trial->gene(index, selectedIndividual->gene(index));

			}
			delete [] indexAngleChangedArray;
			delete [] indexOfDihedralAngleAroundAlphaCarbon;
		}
	}


	// Two conformations are generated by randomly replacing one of the eight groups of dihedral angles of the seed conformation 
	// with a corresponding group of dihedral angles of a randomly selected conformation in the ***bank***
	for(i=6; i<8; i++) {
		GARealGenome* trial = dynamic_cast<GARealGenome*>(&(trialPopulation->individual(i)));
		while(computerGenomeDistance(seedConformation, trial) < 30) {
			int IndexOfGroundAngleChanged = GARandomInt(1,8);
			int indexOfSelectedIndividual = GARandomInt(0, bankSize-1);
			GARealGenome* selectedIndividual = dynamic_cast<GARealGenome*>(&(bank->individual(indexOfSelectedIndividual)));
			
			if(IndexOfGroundAngleChanged == 1) {		// group1: Tyr-phi, Tyr-psi, Tyr-omega, 0-2
				trial->gene(0, selectedIndividual->gene(0));
				trial->gene(1, selectedIndividual->gene(1));
				trial->gene(2, selectedIndividual->gene(2));
			}else if(IndexOfGroundAngleChanged == 2) {	// group2: Tyr-chi1, Tyr-chi2, Tyr-chi3, 3-5
				trial->gene(3, selectedIndividual->gene(3));
				trial->gene(4, selectedIndividual->gene(4));
				trial->gene(5, selectedIndividual->gene(5));
			}else if(IndexOfGroundAngleChanged == 3) {	// group3: Gly1-phi, Gly1-psi, Gly1-omega, 6-8
				trial->gene(6, selectedIndividual->gene(6));
				trial->gene(7, selectedIndividual->gene(7));
				trial->gene(8, selectedIndividual->gene(8));
			}else if(IndexOfGroundAngleChanged == 4) { // group4: Gly2-phi, Gly2-psi, Gly2-omega, 9-11
				trial->gene(9,  selectedIndividual->gene(9));
				trial->gene(10, selectedIndividual->gene(10));
				trial->gene(11, selectedIndividual->gene(11));
			}else if(IndexOfGroundAngleChanged == 5) {	// group5: Phe-phi, Phe-psi, Phe-omega, 12-14
				trial->gene(12, selectedIndividual->gene(12));
				trial->gene(13, selectedIndividual->gene(13));
				trial->gene(14, selectedIndividual->gene(14));
			}else if(IndexOfGroundAngleChanged == 6) {	// group6: Phe-chi1, Phe-chi2, 15-16
				trial->gene(15, selectedIndividual->gene(15));
				trial->gene(16, selectedIndividual->gene(16));
			}else if(IndexOfGroundAngleChanged == 7) {  // group7: Met-phi, Met-psi, Met-omega, 17-19
				trial->gene(17, selectedIndividual->gene(17));
				trial->gene(18, selectedIndividual->gene(18));
				trial->gene(19, selectedIndividual->gene(19));
			}else if(IndexOfGroundAngleChanged == 8) {	// group8: Met-chi1, Met-chi2, Met-chi3, Met-chi4; 20-23
				trial->gene(20, selectedIndividual->gene(20));
				trial->gene(21, selectedIndividual->gene(21));
				trial->gene(22, selectedIndividual->gene(22));
				trial->gene(23, selectedIndividual->gene(23));
			}
		}
	}
	
	// Two conformations are generated using connected groups instead of groups. 
	// For Met-enkephalin we used seven connected groups
	for(i=8; i<10; i++){
		GARealGenome* trial = dynamic_cast<GARealGenome*>(&(trialPopulation->individual(i)));
		while(computerGenomeDistance(seedConformation, trial) < 30) {
			int IndexOfGroundAngleChanged = GARandomInt(1,7);
			int indexOfSelectedIndividual = GARandomInt(0, bankSize-1);
			GARealGenome* selectedIndividual = dynamic_cast<GARealGenome*>(&(bank->individual(indexOfSelectedIndividual)));
			if(IndexOfGroundAngleChanged == 1) {				// 1-2-3
				trial->gene(0, selectedIndividual->gene(0));
				trial->gene(1, selectedIndividual->gene(1));
				trial->gene(2, selectedIndividual->gene(2));
				trial->gene(3, selectedIndividual->gene(3));
				trial->gene(4, selectedIndividual->gene(4));
				trial->gene(5, selectedIndividual->gene(5));
				trial->gene(6, selectedIndividual->gene(6));
				trial->gene(7, selectedIndividual->gene(7));
				trial->gene(8, selectedIndividual->gene(8));
			}else if(IndexOfGroundAngleChanged == 2) {			// 1-3-4
				trial->gene(0, selectedIndividual->gene(0));
				trial->gene(1, selectedIndividual->gene(1));
				trial->gene(2, selectedIndividual->gene(2));
				trial->gene(6, selectedIndividual->gene(6));
				trial->gene(7, selectedIndividual->gene(7));
				trial->gene(8, selectedIndividual->gene(8));
				trial->gene(9,  selectedIndividual->gene(9));
				trial->gene(10, selectedIndividual->gene(10));
				trial->gene(11, selectedIndividual->gene(11));
			}else if(IndexOfGroundAngleChanged == 3) {			// 3-4-5
				trial->gene(6, selectedIndividual->gene(6));
				trial->gene(7, selectedIndividual->gene(7));
				trial->gene(8, selectedIndividual->gene(8));
				trial->gene(9,  selectedIndividual->gene(9));
				trial->gene(10, selectedIndividual->gene(10));
				trial->gene(11, selectedIndividual->gene(11));
				trial->gene(12, selectedIndividual->gene(12));
				trial->gene(13, selectedIndividual->gene(13));
				trial->gene(14, selectedIndividual->gene(14));
			}else if(IndexOfGroundAngleChanged == 4) {			//4-5-6
				trial->gene(9,  selectedIndividual->gene(9));
				trial->gene(10, selectedIndividual->gene(10));
				trial->gene(11, selectedIndividual->gene(11));
				trial->gene(12, selectedIndividual->gene(12));
				trial->gene(13, selectedIndividual->gene(13));
				trial->gene(14, selectedIndividual->gene(14));
				trial->gene(15, selectedIndividual->gene(15));
				trial->gene(16, selectedIndividual->gene(16));
			}else if(IndexOfGroundAngleChanged == 5) {			//4-5-7
				trial->gene(9,  selectedIndividual->gene(9));
				trial->gene(10, selectedIndividual->gene(10));
				trial->gene(11, selectedIndividual->gene(11));
				trial->gene(12, selectedIndividual->gene(12));
				trial->gene(13, selectedIndividual->gene(13));
				trial->gene(14, selectedIndividual->gene(14));
				trial->gene(17, selectedIndividual->gene(17));
				trial->gene(18, selectedIndividual->gene(18));
				trial->gene(19, selectedIndividual->gene(19));
			}else if(IndexOfGroundAngleChanged == 6) {			//5-6-7
				trial->gene(12, selectedIndividual->gene(12));
				trial->gene(13, selectedIndividual->gene(13));
				trial->gene(14, selectedIndividual->gene(14));
				trial->gene(15, selectedIndividual->gene(15));
				trial->gene(16, selectedIndividual->gene(16));
				trial->gene(17, selectedIndividual->gene(17));
				trial->gene(18, selectedIndividual->gene(18));
				trial->gene(19, selectedIndividual->gene(19));
			}else if(IndexOfGroundAngleChanged == 7) {			//5-7-8
				trial->gene(12, selectedIndividual->gene(12));
				trial->gene(13, selectedIndividual->gene(13));
				trial->gene(14, selectedIndividual->gene(14));
				trial->gene(17, selectedIndividual->gene(17));
				trial->gene(18, selectedIndividual->gene(18));
				trial->gene(19, selectedIndividual->gene(19));
				trial->gene(20, selectedIndividual->gene(20));
				trial->gene(21, selectedIndividual->gene(21));
				trial->gene(22, selectedIndividual->gene(22));
				trial->gene(23, selectedIndividual->gene(23));
			}
		}
	}
	return trialPopulation;
}


void CSAAlgorithm::upDateBank(GAPopulation* trialPopulation, GAPopulation* bankPopulation) {
	for(int i=0; i<trialPopulation->size(); i++) {
		GARealGenome* trial = dynamic_cast<GARealGenome*>(&trialPopulation->individual(i));
		GAGenome* nearestBankIndividual = findNearestConformationFromBank(trial, bankPopulation);
		double diMin = computerGenomeDistance(trial,nearestBankIndividual);
		if(diMin < getCurrentDcut()) {
			if(trial->score() < nearestBankIndividual->score()) {
				GARealGenome* ni = dynamic_cast<GARealGenome*>(nearestBankIndividual);
				for(int j=0; j<ni->length(); j++) {
					ni->gene(j, trial->gene(j));
					ni->score(trial->score());
				}
				setGenomeSeedStatus(ni, DEUnknown);
			}
		} else {
			GAGenome* worstGenome = findWorstConformationFromBank(bankPopulation);
			if(trial->score()<worstGenome->score()) {
				GARealGenome* ni = dynamic_cast<GARealGenome*>(worstGenome);
				for(int j=0; j<ni->length(); j++) {
					ni->gene(j, trial->gene(j));
					ni->score(trial->score());
				}
				setGenomeSeedStatus(ni, DEUnknown);
			}
		}
	}
}



GAGenome* CSAAlgorithm::findNearestConformationFromBank(GAGenome* genome, GAPopulation* bank){
	double nearestDistance = 100000000;
	GAGenome* nearestGenome = 0;

	for(int i=0; i<bank->size(); i++) {
		double dist = computerGenomeDistance(genome, &bank->individual(i));
		if (dist < nearestDistance) {
			nearestDistance = dist;
			nearestGenome= &bank->individual(i);
		}
	}

	return nearestGenome;
}

GAGenome* CSAAlgorithm::findWorstConformationFromBank(GAPopulation* bank) {
	GAGenome* worstGenome = 0;
	double worstValue = -100;

	for(int i=0; i<bank->size(); i++) {
		double value = bank->individual(i).score();
		if (value > worstValue) {
			worstValue = value;
			worstGenome = &bank->individual(i);
		}
	}
	return worstGenome;
}










void CSAAlgorithm::multipleEnergyMinimize(GAPopulation& p) {
	int popSize = p.size();
	int genomeLength = dynamic_cast<GARealGenome*>(&(p.individual(0)))->length();

	double **arrayGeom = new double*[popSize];
	for(int i=0; i<popSize; i++) {
		arrayGeom[i] = new double [genomeLength];
	}
	for(i=0; i<popSize; i++) {
		for(int j=0; j<genomeLength; j++) {
			arrayGeom[i][j] = 0.0;
		}
	}
	double *resultArray = new double[popSize]; for(i=0; i<popSize; i++) resultArray[i] = 0.0;


	for(i=0; i<popSize; i++) {
		GARealGenome* triali = dynamic_cast<GARealGenome*>(&(p.individual(i)));
		for(int j=0; j<genomeLength; j++) {
			arrayGeom[i][j] = triali->gene(j);
		}
	}
	
	EnergyCalculator energyCal;
	energyCal.multipleEnergyMinimize(arrayGeom, popSize, genomeLength, resultArray);
	energyEval += energyCal.getEvalCount();
	energyEvalSec += energyCal.getEvalSec( );
	energyMinimizedValue += popSize;


	for(i=0; i<popSize; i++) {
		GARealGenome* triali = dynamic_cast<GARealGenome*>(&(p.individual(i)));
		triali->score(resultArray[i]);
	}
	p.evaluate(gaFalse);


	for(i=0; i<popSize; i++) delete[] arrayGeom[i]; delete [] arrayGeom;
	delete [] resultArray;
}

double CSAAlgorithm::computerGenomeDistance(GAGenome* g1, GAGenome* g2) {
	double distance = 0.0;

	GARealGenome *rg1 = dynamic_cast<GARealGenome*>(g1);
	GARealGenome *rg2 = dynamic_cast<GARealGenome*>(g2);
	int genomeLength = rg1->length();

	double *rg1Array = new double[genomeLength];
	double *rg2Array = new double[genomeLength];
	for(int i=0; i<genomeLength; i++) {
		rg1Array[i] = rg1->gene(i);
		rg2Array[i] = rg2->gene(i);
	}
	
	distance = computeModLeastPositiveValueVector(rg1Array, rg2Array, genomeLength);
	delete [] rg1Array;
	delete [] rg2Array;

	return distance;
}

double CSAAlgorithm::computeRMSDDistance(double *geomAngle1, double*geomAngle2, int angleSize){
	EnkephalinPDB refPDB; refPDB.setPDBFileName("dref.pdb");
	EnkephalinPDB movPDB; movPDB.setPDBFileName("dmov.pdb");
	EnergyCalculator energyCal;
	energyCal.setOutputPDBFormat(true);
	RMSD rmsdCal;

	energyCal.setPDBFile("dref");
	energyCal.singleEnergyEvaluate(geomAngle1, angleSize);
	if(!refPDB.readPDB("dref.pdb")) {cout << "reference pdb file read error!", cout.flush(); return 0.0;}

	energyCal.setPDBFile("dmov");
	energyCal.singleEnergyEvaluate(geomAngle2, angleSize);
	if(!movPDB.readPDB("dmov.pdb")) {cout << "mov pdb file read error!", cout.flush(); return 0.0;}

	EnkephalinPDB::RMSDTYPE rmsdType = EnkephalinPDB::AllAtom;
	double ** ref_xlist = 0;
	double ** mov_xlist = 0;
	int number = 0;

	ref_xlist = refPDB.extractRMSDTypeArray(rmsdType,number);
	mov_xlist = movPDB.extractRMSDTypeArray(rmsdType,number);

	double rmsdDistance = rmsdCal.fast_rmsd(ref_xlist, mov_xlist, number);
	refPDB.freeArray(ref_xlist, number);
	movPDB.freeArray(mov_xlist, number);

	return rmsdDistance;
}

double CSAAlgorithm::computerGenomeRMSDDistance(GAGenome* g1, GAGenome* g2) {
	double distance = 0.0;

	GARealGenome *rg1 = dynamic_cast<GARealGenome*>(g1);
	GARealGenome *rg2 = dynamic_cast<GARealGenome*>(g2);
	int genomeLength = rg1->length();

	double *rg1Array = new double[genomeLength];
	double *rg2Array = new double[genomeLength];
	for(int i=0; i<genomeLength; i++) {
		rg1Array[i] = rg1->gene(i);
		rg2Array[i] = rg2->gene(i);
	}
	
	distance = computeRMSDDistance(rg1Array, rg2Array, genomeLength);

	delete [] rg1Array;
	delete [] rg2Array;

	return distance;
}

double CSAAlgorithm::distanceAverage(GAPopulation& p) {
	int popSize = p.size();
	int genomeLength = dynamic_cast<GARealGenome*>(&(p.individual(0)))->length();
	
	double sumAve = 0.0;
	for(int i=0; i<popSize; i++) {
		for(int j=i+1; j<popSize; j++) {
			sumAve += computerGenomeDistance(&p.individual(i), &p.individual(j));
		}
	}
	double ave = sumAve/(popSize*(popSize-1)/2.0);
	return ave;
}


void CSAAlgorithm::screenPrint(GAGenome* g) {
	GARealGenome *rg = dynamic_cast<GARealGenome*>(g);
	cout <<rg->score() << endl;
	/*
	for(int i=0; i<rg->length(); i++) {
		cout << rg->gene(i) << "\t";
	}
	*/
	//cout << endl;
}

void CSAAlgorithm::screenPrint(GAPopulation* p) {
	for(int i=0; i<p->size(); i++) {
		screenPrint(&p->individual(i));
	}
}
